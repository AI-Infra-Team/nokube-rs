name: Release

on:
  push:
    tags:
      - 'v*'
      - 'release-*'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.ver.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.x
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements-ci.txt

      - name: Read version from Cargo.toml
        id: ver
        run: |
          TAG=$(python scripts/tools/get_version.py --prefix-v)
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Computed tag: $TAG"
          if [[ "${{ github.ref_type }}" == "tag" ]] && [[ "${{ github.ref_name }}" != "$TAG" ]]; then
            echo "::warning::Pushed tag ${{ github.ref_name }} mismatches Cargo.toml version $TAG"
          fi

      - name: Pre-create release (no assets)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python scripts/release.py --tag "${{ steps.ver.outputs.tag }}" --name "nokube ${{ steps.ver.outputs.tag }}"

  build-linux:
    needs: prepare-release
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86_64
            target: x86_64-unknown-linux-gnu
          - arch: arm64
            target: aarch64-unknown-linux-gnu
    env:
      RELEASE_TAG: ${{ needs.prepare-release.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.x
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements-ci.txt

      - name: Build and package (x86_64 via container)
        if: matrix.arch == 'x86_64'
        run: |
          sudo apt-get update
          xargs -a scripts/apt-packages-ci.txt -r sudo apt-get install -y --no-install-recommends
          docker --version
          sudo systemctl is-active --quiet docker || true
          python3 scripts/build_with_container.py -o dist -p --package-out dist/nokube-${{ env.RELEASE_TAG }}-linux-x86_64.run --no-copy-libs
          mv dist/nokube dist/nokube-${{ env.RELEASE_TAG }}-linux-x86_64

      - name: Build and package (arm64 via QEMU)
        if: matrix.arch == 'arm64'
        uses: uraimo/run-on-arch-action@v2.7.2
        with:
          arch: aarch64
          distro: ubuntu22.04
          base_image: ubuntu:22.04
          githubToken: ${{ github.token }}
          dockerRunArgs: |
            -v ${{ github.workspace }}:/github/workspace
          install: |
            set -euo pipefail
            apt-get update
            # Inline apt packages (cannot access /github/workspace during image build)
            DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
              build-essential pkg-config libssl-dev libssh2-1-dev zlib1g-dev protobuf-compiler cmake curl ca-certificates git
            # Install rustup with default toolchain; select exact toolchain later at runtime
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            . /root/.cargo/env
            rustup --version || true
          run: |
            set -euo pipefail
            . /root/.cargo/env
            # The action automatically mounts the repo to /github/workspace and cd's there.
            # Select toolchain from repository config
            if [[ -f rust-toolchain.toml ]]; then
              TOOLCHAIN=$(sed -n 's/^channel\s*=\s*"\([^"]*\)"/\1/p' rust-toolchain.toml || true)
              if [[ -n "${TOOLCHAIN:-}" ]]; then
                rustup toolchain install "$TOOLCHAIN"
                rustup default "$TOOLCHAIN"
              fi
            fi
            rustup component add rustfmt clippy || true
            rustc --version
            cargo --version
            # Build
            cargo build --release
            mkdir -p dist
            cp target/release/nokube dist/nokube-${{ env.RELEASE_TAG }}-linux-arm64
            # Package inline (no external script)
            BIN=target/release/nokube
            STAGE=$(mktemp -d)
            mkdir -p "$STAGE/lib"
            cp -a "$BIN" "$STAGE/nokube"
            mapfile -t ALL_LIBS < <(ldd "$BIN" | sed -n 's/.*=> \(\/[^ ]*\).*/\1/p; s/^\s*\(\/[^ ]*\).*/\1/p' | sort -u)
            GLIBC_BASENAMES=(libc.so libc.so.6 libpthread.so libpthread.so.0 librt.so librt.so.1 libdl.so libdl.so.2 ld-linux-aarch64.so.1 ld-linux.so ld-linux.so.2)
            for lib in "${ALL_LIBS[@]}"; do
              base=$(basename "$lib"); skip=0; for g in "${GLIBC_BASENAMES[@]}"; do [[ "$base" == "$g" ]] && skip=1 && break; done; \
              if [[ $skip -eq 0 && -f "$lib" ]]; then cp -a "$lib" "$STAGE/lib/$base"; fi; \
            done
            cat > "$STAGE/stub.sh" << 'STUB'
            #!/usr/bin/env bash
            set -euo pipefail
            SELF="$0"
            START_LINE=$(awk '/^__NOKUBE_PAYLOAD_BELOW__/ {print NR + 1; exit}' "$SELF")
            TMPDIR="${TMPDIR:-/tmp}/nokube-$$"
            mkdir -p "$TMPDIR"
            trap 'rm -rf "$TMPDIR"' EXIT
            tail -n +"$START_LINE" "$SELF" | tar -xz -C "$TMPDIR"
            export LD_LIBRARY_PATH="$TMPDIR/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
            exec "$TMPDIR/nokube" "$@"
            __NOKUBE_PAYLOAD_BELOW__
            STUB
            tar -C "$STAGE" -czf "$STAGE/payload.tar.gz" nokube lib
            cat "$STAGE/stub.sh" "$STAGE/payload.tar.gz" > dist/nokube-${{ env.RELEASE_TAG }}-linux-arm64.run
            chmod +x dist/nokube-${{ env.RELEASE_TAG }}-linux-arm64.run

      - name: Upload assets to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ env.RELEASE_TAG }}
        run: |
          ASSET1="dist/nokube-${{ env.RELEASE_TAG }}-linux-${{ matrix.arch }}.run"
          ASSET2="dist/nokube-${{ env.RELEASE_TAG }}-linux-${{ matrix.arch }}"
          python scripts/release.py \
            --tag "${{ env.RELEASE_TAG }}" \
            --name "nokube ${{ env.RELEASE_TAG }}" \
            --asset "$ASSET1" \
            --asset "$ASSET2"
